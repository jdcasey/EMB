BACKGROUND:

DefaultComponentRepository:

    public <T> ComponentDescriptor<T> getComponentDescriptor( Class<T> type, String role, String roleHint )
    {
        Multimap<String, ComponentDescriptor<?>> roleHintIndex = getComponentDescriptors( role );

        Collection<ComponentDescriptor<?>> descriptors;

        if ( StringUtils.isNotEmpty( roleHint ) )
        {
            // specific role hint -> get only those
            descriptors = roleHintIndex.get( roleHint );
        }
        else
        {
            // missing role hint -> get all (wildcard)
            Collection<ComponentDescriptor<?>> allDescriptors = new ArrayList<ComponentDescriptor<?>>();

            descriptors = roleHintIndex.get( PlexusConstants.PLEXUS_DEFAULT_HINT );
            if ( descriptors != null )
            {
                allDescriptors.addAll( descriptors );
            }

            for ( String hint : roleHintIndex.keySet() )
            {
                descriptors = roleHintIndex.get( hint );
                if ( descriptors != null )
                {
                    allDescriptors.addAll( descriptors );
                }
            }

            descriptors = allDescriptors;
        }

        for ( ComponentDescriptor<?> descriptor : descriptors )
        {
            Class<?> implClass = descriptor.getImplementationClass();
            if ( isAssignableFrom( type, implClass ) )
            {
                return (ComponentDescriptor<T>) descriptor;
            }
            else if ( Object.class == implClass && role.equals( type.getName() ) )
            {
                return (ComponentDescriptor<T>) descriptor;
            }
        }
                
        return null;
    }

===

InitializeComponentRegistryPhase:

    public void execute( ContainerInitializationContext context )
        throws ContainerInitializationException
    {
        ComponentRepository repository = getComponentRepository( context );

        LifecycleHandlerManager lifecycleHandlerManager = getLifecycleHandlerManager( context );

        ComponentRegistry componentRegistry = new DefaultComponentRegistry( context.getContainer(),
            repository,
            lifecycleHandlerManager );

        componentRegistry.registerComponentManagerFactory( new PerLookupComponentManagerFactory() );

        componentRegistry.registerComponentManagerFactory( new SingletonComponentManagerFactory() );

        context.getContainer().setComponentRegistry( componentRegistry );
    }

===

DefaultComponentRegistry:

    public <T> T lookup( Class<T> type, String role, String roleHint ) throws ComponentLookupException
    {
        // verify arguments
        if ( type == null )
        {
            throw new NullPointerException( "type is null" );
        }
        if ( role == null )
        {
            throw new NullPointerException( "role is null" );
        }
        if ( roleHint == null )
        {
            roleHint = "";
        }

        return getComponent( type, role, roleHint, null );
    }


----


In DefaultContainerConfiguration...

- Possibly modify this to return a custom component repository that implements selector logic and defaults to
the original behavior if the selector fails:

    public ComponentRepository getComponentRepository()
    {
        if ( componentRepository == null )
        {
            componentRepository = new DefaultComponentRepository();
        }

        return componentRepository;
    }


- Possibly modify this to return a custom registry-init phase, which in turn 
injects a custom registry that does a selector-style lookup for role-hint before defaulting as the 
original one does:

    public ContainerConfiguration setInitializationPhases( ContainerInitializationPhase[] initializationPhases )
    {
        this.initializationPhases = initializationPhases;

        return this;
    }
